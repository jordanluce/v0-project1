"use client"

import "./LineupSelectionModal.css"
import { useState, useContext, useEffect, useRef, useCallback } from "react"
import { AppContext } from "./App"
import LineupManagement from "./LineupManagement"

const LineupSelectionModal = ({ onClose }) => {
  const { players, lineups, setLineups, activeTeamId, activeTeam, setCurrentLineup, currentLineup, setNotification } =
    useContext(AppContext)
  // Update the state to include a new tab option and track lineup source
  const [activeTab, setActiveTab] = useState("manual")
  const [autoLineups, setAutoLineups] = useState([])
  const [filteredLineups, setFilteredLineups] = useState([])
  const [groupedLineups, setGroupedLineups] = useState({})
  const [expandedGroups, setExpandedGroups] = useState({})
  const [selectedAutoLineup, setSelectedAutoLineup] = useState(null)
  const [lineupToSave, setLineupToSave] = useState(null)
  const [showNamingPopup, setShowNamingPopup] = useState(false)
  const [errorMessage, setErrorMessage] = useState("")
  const [isGenerating, setIsGenerating] = useState(false)
  const [cachedLineups, setCachedLineups] = useState({})
  const [selectedFilterPlayers, setSelectedFilterPlayers] = useState([])
  const generationTimeoutRef = useRef(null)
  const observerRef = useRef(null)
  const visibleItemsRef = useRef(new Set())

  // Add state to track manual and auto-generated lineups
  const [manualLineups, setManualLineups] = useState([])
  const [autoGeneratedLineups, setAutoGeneratedLineups] = useState([])

  // Add a state for tracking the lineup being deleted
  const [lineupToDelete, setLineupToDelete] = useState(null)
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false)

  // Add new state variables for the Smart Suggestions feature after the existing state declarations
  const [strategyPreference, setStrategyPreference] = useState("balanced")
  const [suggestedLineup, setSuggestedLineup] = useState(null)
  const [isShowingSuggestion, setIsShowingSuggestion] = useState(false)
  const [isSuggestingLineup, setIsSuggestingLineup] = useState(false)
  const [suggestionError, setSuggestionError] = useState("")

  // Add a new state variable for tracking filter section expansion after the other state declarations
  const [isFilterSectionExpanded, setIsFilterSectionExpanded] = useState(false)

  // Check competition level
  const isInternational = activeTeam?.competitionLevel === "International"
  const isNational = activeTeam?.competitionLevel === "National"
  const isEuroCup = activeTeam?.competitionLevel === "Eurocup"

  // Create a ref at the component level
  const prevPlayerIdsRef = useRef("")

  // Create a throttled state update function
  // Just remove the throttledSetFilteredLineups function entirely and use setFilteredLineups directly

  // Get only players for the active team
  const teamPlayers = players.filter((player) => player.teamId === activeTeamId)

  // Calculate bonuses based on player categories and competition level
  const calculateBonuses = useCallback(
    (selectedPlayers) => {
      // Ensure selectedPlayers is an array
      if (!Array.isArray(selectedPlayers) || selectedPlayers.length === 0) {
        return {
          totalBonus: 0,
          details: [],
        }
      }

      // For International teams, no bonuses
      if (isInternational) {
        return {
          totalBonus: 0,
          details: [],
        }
      }

      // For EuroCup, use standard EuroCup rules
      if (isEuroCup) {
        let totalBonus = 0
        let femaleCount = 0
        let juniorMaleCount = 0
        let juniorFemaleCount = 0

        selectedPlayers.forEach((player) => {
          if (!player) return // Skip null/undefined players

          const category = player.category || "Senior"

          if (category === "Female") {
            femaleCount++
            totalBonus += 1.5
          } else if (category === "Junior") {
            juniorMaleCount++
            totalBonus += 1.0
          } else if (category === "Junior Female") {
            juniorFemaleCount++
            totalBonus += 2.0
          }
        })

        return {
          totalBonus,
          femaleCount,
          juniorMaleCount,
          juniorFemaleCount,
          details: [
            { type: "Female", count: femaleCount, bonus: femaleCount * 1.5 },
            { type: "Junior Male", count: juniorMaleCount, bonus: juniorMaleCount * 1.0 },
            { type: "Junior Female", count: juniorFemaleCount, bonus: juniorFemaleCount * 2.0 },
          ].filter((item) => item.count > 0),
        }
      }

      // For National teams, use the team's custom rules
      if (isNational && activeTeam?.rules) {
        const rules = activeTeam.rules
        let totalBonus = 0
        let femaleCount = 0
        let juniorMaleCount = 0
        let juniorFemaleCount = 0
        let femaleAbleBodyCount = 0
        let maleAbleBodyCount = 0

        // Count players by category
        selectedPlayers.forEach((player) => {
          if (!player) return // Skip null/undefined players

          const category = player.category || "Senior"

          if (category === "Female") {
            femaleCount++
          } else if (category === "Junior") {
            juniorMaleCount++
          } else if (category === "Junior Female") {
            juniorFemaleCount++
          }

          // Count female able-bodied players
          if (player.isAbleBody && player.gender === "female") {
            femaleAbleBodyCount++
          }

          // Count male able-bodied players
          if (player.isAbleBody && player.gender === "male") {
            maleAbleBodyCount++
          }
        })

        // Apply bonuses based on team rules and limits
        // If max value is -1 (unlimited), apply bonus to all players of that category
        const femaleBonusCount =
          !rules.maxFemales || rules.maxFemales === -1 ? femaleCount : Math.min(femaleCount, rules.maxFemales)

        const juniorBonusCount =
          !rules.maxJuniors || rules.maxJuniors === -1 ? juniorMaleCount : Math.min(juniorMaleCount, rules.maxJuniors)

        const juniorFemaleBonusCount =
          !rules.maxJuniorFemales || rules.maxJuniorFemales === -1
            ? juniorFemaleCount
            : Math.min(juniorFemaleCount, rules.maxJuniorFemales)

        const femaleBonus = femaleBonusCount * (rules.femaleBonus || 0)
        const juniorBonus = juniorBonusCount * (rules.juniorBonus || 0)
        const juniorFemaleBonus = juniorFemaleBonusCount * (rules.juniorFemaleBonus || 0)
        const femaleAbleBodyBonus = femaleAbleBodyCount * (rules.femaleAbleBodyBonus || 0)
        // Male able-bodied players don't get bonus points

        totalBonus = femaleBonus + juniorBonus + juniorFemaleBonus + femaleAbleBodyBonus

        return {
          totalBonus,
          femaleCount,
          juniorMaleCount,
          juniorFemaleCount,
          femaleAbleBodyCount,
          maleAbleBodyCount,
          femaleBonusCount,
          juniorBonusCount,
          juniorFemaleBonusCount,
          details: [
            {
              type: "Female",
              count: femaleCount,
              bonusCount: femaleBonusCount,
              bonusPerPlayer: rules.femaleBonus || 0,
              bonus: femaleBonus,
              unlimited: !rules.maxFemales || rules.maxFemales === -1,
            },
            {
              type: "Junior Male",
              count: juniorMaleCount,
              bonusCount: juniorBonusCount,
              bonusPerPlayer: rules.juniorBonus || 0,
              bonus: juniorBonus,
              unlimited: !rules.maxJuniors || rules.maxJuniors === -1,
            },
            {
              type: "Junior Female",
              count: juniorFemaleCount,
              bonusCount: juniorFemaleBonusCount,
              bonusPerPlayer: rules.juniorFemaleBonus || 0,
              bonus: juniorFemaleBonus,
              unlimited: !rules.maxJuniorFemales || rules.maxJuniorFemales === -1,
            },
            {
              type: "Female Able-Bodied",
              count: femaleAbleBodyCount,
              bonusCount: femaleAbleBodyCount,
              bonusPerPlayer: rules.femaleAbleBodyBonus || 0,
              bonus: femaleAbleBodyBonus,
              unlimited: true, // Always unlimited for able-bodied
            },
          ].filter((item) => item.count > 0),
        }
      }

      // Default fallback
      return {
        totalBonus: 0,
        details: [],
      }
    },
    [isInternational, isEuroCup, isNational, activeTeam],
  )

  const applyFilters = useCallback(
    (lineups) => {
      // Don't run if no lineups
      if (!lineups || lineups.length === 0) {
        setFilteredLineups([])
        setGroupedLineups({})
        return
      }

      let filtered = [...lineups]

      // Apply player filters if any are selected
      if (selectedFilterPlayers.length > 0) {
        filtered = filtered.filter((lineup) => {
          // Check if all selected filter players are in this lineup
          return selectedFilterPlayers.every((filterId) => lineup.players.some((player) => player.id === filterId))
        })
      }

      // Set filtered lineups directly instead of using throttled function
      setFilteredLineups(filtered)

      // Update grouped lineups in a separate operation
      const grouped = filtered.reduce((acc, lineup) => {
        const classificationKey = lineup.totalClassification.toFixed(1)
        if (!acc[classificationKey]) {
          acc[classificationKey] = []
        }
        acc[classificationKey].push(lineup)
        return acc
      }, {})

      setGroupedLineups(grouped)

      if (filtered.length === 0 && lineups.length > 0) {
        setErrorMessage("No lineups match your filter criteria. Try adjusting your filters.")
      } else {
        setErrorMessage("")
      }
    },
    [selectedFilterPlayers],
  )

  // Helper function for generating subcombinations
  const getSubCombinations = useCallback((arr, k) => {
    const result = []

    // Iterative combination algorithm (more efficient than recursive for large arrays)
    const generateCombos = (start, combo) => {
      if (combo.length === k) {
        result.push([...combo])
        return
      }

      // Optimization: early termination if we can't possibly complete a combination
      if (arr.length - start < k - combo.length) {
        return
      }

      for (let i = start; i < arr.length; i++) {
        combo.push(arr[i])
        generateCombos(i + 1, combo)
        combo.pop()
      }
    }

    generateCombos(0, [])
    return result
  }, [])

  // Helper function to generate all combinations of size k from array arr
  const getCombinations = useCallback(
    (arr, k) => {
      // For large player pools, limit the number of combinations to prevent browser freezing
      if (arr.length > 15 && k === 5) {
        console.log("Using optimized combination generation for large player pool:", arr.length)

        // If we have too many players, use a more efficient approach
        // First, sort players by classification (highest first)
        const sortedPlayers = [...arr].sort(
          (a, b) => Number.parseFloat(b.classification) - Number.parseFloat(a.classification),
        )

        // Create strategic combinations instead of all possible ones
        const result = []

        // Add some combinations with highest classification players
        const highClassPlayers = sortedPlayers.slice(0, Math.min(10, sortedPlayers.length))
        const highCombos = getSubCombinations(highClassPlayers, k)
        result.push(...highCombos)

        // Add some combinations with lowest classification players
        const lowClassPlayers = sortedPlayers.slice(-Math.min(10, sortedPlayers.length))
        const lowCombos = getSubCombinations(lowClassPlayers, k)
        result.push(...lowCombos)

        // Add some mixed combinations
        const mixedPlayers = [
          ...sortedPlayers.slice(0, Math.min(5, sortedPlayers.length)),
          ...sortedPlayers.slice(
            Math.max(0, Math.floor(sortedPlayers.length / 2) - 2),
            Math.min(sortedPlayers.length, Math.floor(sortedPlayers.length / 2) + 3),
          ),
          ...sortedPlayers.slice(-Math.min(5, sortedPlayers.length)),
        ]

        // Remove duplicates from mixedPlayers
        const uniqueMixedPlayers = []
        const seenIds = new Set()

        for (const player of mixedPlayers) {
          if (!seenIds.has(player.id)) {
            seenIds.add(player.id)
            uniqueMixedPlayers.push(player)
          }
        }

        const mixedCombos = getSubCombinations(uniqueMixedPlayers, k)
        result.push(...mixedCombos)

        console.log(`Generated ${result.length} strategic combinations instead of all possible combinations`)
        return result
      }

      // For smaller player pools, use the original algorithm
      return getSubCombinations(arr, k)
    },
    [getSubCombinations],
  )

  // Add a function to get available strategy options based on competition level
  const getAvailableStrategies = useCallback(() => {
    // Define all possible strategies
    const allStrategies = [
      { value: "balanced", label: "Balanced Selection" },
      { value: "prioritizeBonus", label: "Prioritize Bonus Players" },
      { value: "prioritizeMaxClass", label: "Prioritize Maximum Classification" },
      { value: "prioritizeBalanced", label: "Prioritize Balanced Points" },
      { value: "excludeForeign", label: "Exclude Foreign Players" },
      { value: "avoidAbleBody", label: "Avoid Able-Bodied Players" },
    ]

    // Filter strategies based on competition level
    if (isInternational) {
      // International teams: Only show Balanced, Max Classification, and Balanced Points
      return allStrategies.filter((strategy) =>
        ["balanced", "prioritizeMaxClass", "prioritizeBalanced"].includes(strategy.value),
      )
    } else if (isEuroCup) {
      // Eurocup teams: Show all except Foreign and Able-Body options
      return allStrategies.filter((strategy) => !["excludeForeign", "avoidAbleBody"].includes(strategy.value))
    } else {
      // National teams: Show all options
      return allStrategies
    }
  }, [isInternational, isEuroCup])

  // Add an effect to ensure the selected strategy is valid for the current competition level
  useEffect(() => {
    const availableStrategies = getAvailableStrategies()
    const isCurrentStrategyValid = availableStrategies.some((s) => s.value === strategyPreference)

    // If current strategy is not valid for this competition level, reset to "balanced"
    if (!isCurrentStrategyValid) {
      setStrategyPreference("balanced")
    }
  }, [activeTeam?.competitionLevel, getAvailableStrategies, strategyPreference])

  // Add this function after the other helper functions
  const generateSuggestedLineup = useCallback(() => {
    // Reset states
    setSuggestionError("")
    setIsSuggestingLineup(true)
    setSuggestedLineup(null)

    // Only proceed if we have at least 5 players
    if (teamPlayers.length < 5) {
      setSuggestionError("You need at least 5 players to generate a lineup")
      setIsSuggestingLineup(false)
      return
    }

    setTimeout(() => {
      try {
        // Create a copy of team players to work with
        let eligiblePlayers = [...teamPlayers]

        // Apply strategy-specific filtering
        if (strategyPreference === "excludeForeign") {
          // Filter out foreign players if possible (only if we have enough non-foreign players)
          const nonForeignPlayers = eligiblePlayers.filter((p) => !p.isForeign)
          if (nonForeignPlayers.length >= 5) {
            eligiblePlayers = nonForeignPlayers
          }
        } else if (strategyPreference === "avoidAbleBody") {
          // Filter out able-bodied players if possible
          const nonAbleBodyPlayers = eligiblePlayers.filter((p) => !p.isAbleBody)
          if (nonAbleBodyPlayers.length >= 5) {
            eligiblePlayers = nonAbleBodyPlayers
          }
        }

        // Sort players based on strategy
        if (strategyPreference === "prioritizeBonus") {
          // Sort by bonus potential (players with bonus first)
          eligiblePlayers.sort((a, b) => {
            const aBonus = calculateBonuses([a]).totalBonus
            const bBonus = calculateBonuses([b]).totalBonus
            return bBonus - aBonus // Higher bonus first
          })
        } else if (strategyPreference === "prioritizeMaxClass") {
          // Sort by classification (highest first)
          eligiblePlayers.sort((a, b) => Number.parseFloat(b.classification) - Number.parseFloat(a.classification))
        } else if (strategyPreference === "prioritizeBalanced") {
          // No specific sorting, we'll handle balance in the selection algorithm
        }

        // Generate all valid combinations of 5 players
        const combinations = getCombinations(eligiblePlayers, 5)

        // Filter combinations based on competition rules
        const validCombinations = combinations.filter((combo) => {
          // Calculate total classification
          const totalClassification = combo.reduce((sum, player) => sum + Number.parseFloat(player.classification), 0)

          // Check competition level
          if (isInternational) {
            // International: Simple 14.0 limit (no change)
            return totalClassification <= 14.0
          } else if (isEuroCup) {
            // EuroCup: Calculate bonuses
            const bonuses = calculateBonuses(combo)
            const bonusPoints = bonuses.totalBonus

            // NEW VALIDATION LOGIC: Check if (Total Classification - Total Bonus) exceeds 14.5
            if (totalClassification - bonusPoints > 14.5) {
              return false
            }

            // Also check against the 17.0 cap
            return totalClassification <= 17.0
          } else if (isNational && activeTeam?.rules) {
            // National: Check against custom rules
            const rules = activeTeam.rules

            // Calculate bonuses
            const bonuses = calculateBonuses(combo)
            const bonusPoints = bonuses.totalBonus

            // NEW VALIDATION LOGIC: Check if (Total Classification - Total Bonus) exceeds 14.5
            if (totalClassification - bonusPoints > 14.5) {
              return false
            }

            // Check if total classification exceeds the maximum allowed
            if (totalClassification > rules.maxPointsAllowed) {
              return false
            }

            // Check foreign players limit - Properly handle unlimited (-1) case
            const foreignPlayers = combo.filter((p) => p.isForeign)
            if (rules.maxForeignPlayers !== -1 && foreignPlayers.length > rules.maxForeignPlayers) {
              return false
            }

            // Check able-bodied players limit - count both male and female able-bodied players
            const ableBodyPlayers = combo.filter((p) => p.isAbleBody)
            if (ableBodyPlayers.length > rules.maxAbleBodyPlayers) {
              return false
            }

            return true
          }

          // Default fallback
          return totalClassification <= 14.5
        })

        if (validCombinations.length === 0) {
          setSuggestionError(
            "No valid lineups found with the current strategy. Try a different strategy or adjust your player pool.",
          )
          setIsSuggestingLineup(false)
          return
        }

        // Score each valid combination based on the selected strategy
        const scoredCombinations = validCombinations.map((combo) => {
          const totalClassification = combo.reduce((sum, player) => sum + Number.parseFloat(player.classification), 0)
          const bonuses = calculateBonuses(combo)
          const bonusPoints = bonuses.totalBonus
          const totalWithBonuses = totalClassification + bonusPoints

          // Calculate base max classification based on competition level
          let baseMaxClassification = 14.5
          let adjustedMaxClassification = baseMaxClassification

          if (isInternational) {
            baseMaxClassification = 14.0
            adjustedMaxClassification = 14.0
          } else if (isEuroCup) {
            baseMaxClassification = 14.5
            adjustedMaxClassification = Math.min(baseMaxClassification + bonusPoints, 17.0)
          } else if (isNational && activeTeam?.rules) {
            baseMaxClassification = 14.5 // Always 14.5 for National
            adjustedMaxClassification = Math.min(baseMaxClassification + bonusPoints, activeTeam.rules.maxPointsAllowed)
          }

          // Calculate score based on strategy
          let score = 0

          if (strategyPreference === "balanced") {
            // Balanced strategy: reward lineups that:
            // 1. Have a good mix of classifications
            // 2. Use a reasonable amount of the available points
            // 3. Include some bonus players but not excessively

            // Calculate classification spread (standard deviation)
            const classifications = combo.map((p) => Number.parseFloat(p.classification))
            const avg = classifications.reduce((sum, c) => sum + c, 0) / classifications.length
            const variance = classifications.reduce((sum, c) => sum + Math.pow(c - avg, 2), 0) / classifications.length
            const stdDev = Math.sqrt(variance)

            // Reward moderate spread (not too uniform, not too varied)
            const spreadScore = 10 - Math.abs(stdDev - 1.0) * 5 // Optimal spread around 1.0

            // Reward using 85-95% of available points
            const pointsUtilization = totalWithBonuses / adjustedMaxClassification
            const utilizationScore = 10 - Math.abs(pointsUtilization - 0.9) * 20 // Optimal around 90%

            // Reward having some bonus players
            const bonusScore = Math.min(bonusPoints * 2, 10) // Cap at 10 points

            score = spreadScore + utilizationScore + bonusScore
          } else if (strategyPreference === "prioritizeBonus") {
            // Prioritize bonus: reward lineups with the most bonus points
            score = bonusPoints * 10 // Heavy weight on bonus points

            // Secondary consideration: point utilization
            const pointsUtilization = totalWithBonuses / adjustedMaxClassification
            score += pointsUtilization * 5 // Some weight on using available points
          } else if (strategyPreference === "prioritizeMaxClass") {
            // Prioritize maximum classification: reward lineups that use the most points
            const pointsUtilization = totalWithBonuses / adjustedMaxClassification
            score = pointsUtilization * 20 // Heavy weight on point utilization
          } else if (strategyPreference === "prioritizeBalanced") {
            // Prioritize balanced points: reward lineups with even distribution of classifications
            const classifications = combo.map((p) => Number.parseFloat(p.classification))
            const avg = classifications.reduce((sum, c) => sum + c, 0) / classifications.length
            const variance = classifications.reduce((sum, c) => sum + Math.pow(c - avg, 2), 0) / classifications.length
            const stdDev = Math.sqrt(variance)

            // Lower standard deviation means more balanced classifications
            score = 20 - stdDev * 10 // Invert so lower stdDev gives higher score
          } else if (strategyPreference === "excludeForeign") {
            // Exclude foreign players: already filtered above, but give bonus for fewer foreign players
            const foreignCount = combo.filter((p) => p.isForeign).length
            score = 20 - foreignCount * 5 // Fewer foreign players = higher score

            // Secondary consideration: point utilization
            const pointsUtilization = totalWithBonuses / adjustedMaxClassification
            score += pointsUtilization * 3
          } else if (strategyPreference === "avoidAbleBody") {
            // Avoid able-bodied players: already filtered above, but give bonus for fewer able-bodied players
            const ableBodyCount = combo.filter((p) => p.isAbleBody).length
            score = 20 - ableBodyCount * 5 // Fewer able-bodied players = higher score

            // Secondary consideration: point utilization
            const pointsUtilization = totalWithBonuses / adjustedMaxClassification
            score += pointsUtilization * 3
          }

          return {
            combo,
            score,
            totalClassification,
            bonusPoints,
            totalWithBonuses,
            baseMaxClassification,
            adjustedMaxClassification,
          }
        })

        // Sort by score (highest first)
        scoredCombinations.sort((a, b) => b.score - a.score)

        // Take the highest scoring combination
        const bestCombo = scoredCombinations[0]

        // Format the suggested lineup
        const suggestedLineup = {
          id: `suggested-${Date.now()}`,
          players: bestCombo.combo,
          totalClassification: bestCombo.totalClassification,
          bonusPoints: bestCombo.bonusPoints,
          totalWithBonuses: bestCombo.totalWithBonuses,
          baseMaxClassification: bestCombo.baseMaxClassification,
          adjustedMaxClassification: bestCombo.adjustedMaxClassification,
          score: bestCombo.score,
        }

        // Set the suggested lineup
        setSuggestedLineup(suggestedLineup)
        setIsShowingSuggestion(true)
      } catch (error) {
        console.error("Error generating suggested lineup:", error)
        setSuggestionError("An error occurred while generating a suggested lineup. Please try again.")
      } finally {
        setIsSuggestingLineup(false)
      }
    }, 100) // Short timeout to allow UI to update
  }, [
    teamPlayers,
    strategyPreference,
    isInternational,
    isEuroCup,
    isNational,
    activeTeam,
    calculateBonuses,
    getCombinations,
  ])

  // Add this function to handle confirming the suggested lineup
  const confirmSuggestedLineup = (name) => {
    if (!suggestedLineup) return false

    if (!name || !name.trim()) {
      return false
    }

    // Calculate bonuses for the lineup
    const bonuses = calculateBonuses(suggestedLineup.players)

    const newLineup = {
      id: Date.now().toString(),
      teamId: activeTeamId,
      name: name,
      playerIds: suggestedLineup.players.map((player) => player.id),
      totalClassification: suggestedLineup.totalClassification,
      bonuses: bonuses,
      adjustedMaxClassification: suggestedLineup.adjustedMaxClassification,
      rating: 0,
      source: "suggested",
    }

    setLineups([...lineups, newLineup])
    setCurrentLineup(newLineup)
    setIsShowingSuggestion(false)
    setSuggestedLineup(null)
    setShowNamingPopup(false)

    // Show success notification
    setNotification({
      show: true,
      message: "Suggested lineup has been saved and activated!",
    })
    setTimeout(() => setNotification({ show: false, message: "" }), 3000)

    return true
  }

  // Add this helper function to get a readable strategy name
  const getStrategyName = (strategy) => {
    switch (strategy) {
      case "balanced":
        return "Balanced"
      case "prioritizeBonus":
        return "Bonus-Focused"
      case "prioritizeMaxClass":
        return "Max Classification"
      case "prioritizeBalanced":
        return "Balanced Points"
      case "excludeForeign":
        return "Domestic Players"
      case "avoidAbleBody":
        return "Wheelchair Players"
      default:
        return "Custom"
    }
  }

  // Generate all valid combinations of 5 players that follow competition rules
  const generateValidLineups = useCallback(() => {
    // Only proceed if we have at least 5 players
    if (teamPlayers.length < 5) {
      setErrorMessage("You need at least 5 players to generate lineups")
      setAutoLineups([])
      setFilteredLineups([])
      setGroupedLineups({})
      return
    }

    // Add debug logging
    console.log("Generating lineups with:", {
      teamPlayers: teamPlayers.length,
      activeTeamId,
      competitionLevel: activeTeam?.competitionLevel,
      rules: isNational ? activeTeam?.rules : "N/A",
    })

    setIsGenerating(true)
    setErrorMessage("")

    // Use a web worker or setTimeout to prevent UI blocking
    setTimeout(() => {
      try {
        // Generate all combinations of 5 players
        const combinations = getCombinations(teamPlayers, 5)

        console.log(`Generated ${combinations.length} combinations`)

        // Filter combinations based on competition rules
        const validCombinations = combinations.filter((combo) => {
          // Calculate total classification
          const totalClassification = combo.reduce((sum, player) => sum + Number.parseFloat(player.classification), 0)

          // Check competition level
          if (isInternational) {
            // International: Simple 14.0 limit (no change)
            return totalClassification <= 14.0
          } else if (isEuroCup) {
            // EuroCup: Calculate bonuses
            const bonuses = calculateBonuses(combo)
            const bonusPoints = bonuses.totalBonus

            // NEW VALIDATION LOGIC: Check if (Total Classification - Total Bonus) exceeds 14.5
            if (totalClassification - bonusPoints > 14.5) {
              return false
            }

            // Also check against the 17.0 cap
            return totalClassification <= 17.0
          } else if (isNational && activeTeam?.rules) {
            // National: Check against custom rules
            const rules = activeTeam.rules

            // Calculate bonuses
            const bonuses = calculateBonuses(combo)
            const bonusPoints = bonuses.totalBonus

            // NEW VALIDATION LOGIC: Check if (Total Classification - Total Bonus) exceeds 14.5
            if (totalClassification - bonusPoints > 14.5) {
              return false
            }

            // Check if total classification exceeds the maximum allowed
            if (totalClassification > rules.maxPointsAllowed) {
              return false
            }

            // Check foreign players limit - Properly handle unlimited (-1) case
            const foreignPlayers = combo.filter((p) => p.isForeign)
            if (rules.maxForeignPlayers !== -1 && foreignPlayers.length > rules.maxForeignPlayers) {
              return false
            }

            // Check able-bodied players limit - count both male and female able-bodied players
            const ableBodyPlayers = combo.filter((p) => p.isAbleBody)
            if (ableBodyPlayers.length > rules.maxAbleBodyPlayers) {
              return false
            }

            return true
          }

          // Default fallback
          return totalClassification <= 14.5
        })

        console.log(`Found ${validCombinations.length} valid combinations`)

        // Sort by total classification (highest first), including bonuses
        validCombinations.sort((a, b) => {
          const totalA = a.reduce((sum, player) => sum + Number.parseFloat(player.classification), 0)
          const totalB = b.reduce((sum, player) => sum + Number.parseFloat(player.classification), 0)

          const bonusesA = calculateBonuses(a)
          const bonusesB = calculateBonuses(b)

          const totalWithBonusA = totalA + bonusesA.totalBonus
          const totalWithBonusB = totalB + bonusesB.totalBonus

          return totalWithBonusB - totalWithBonusA
        })

        // Update the format for display with competition-specific calculations
        const formattedLineups = validCombinations.map((combo, index) => {
          const totalClassification = combo.reduce((sum, player) => sum + Number.parseFloat(player.classification), 0)
          const bonuses = calculateBonuses(combo)
          const bonusPoints = bonuses.totalBonus
          const totalWithBonuses = totalClassification + bonusPoints

          // Get base max classification based on competition level
          let baseMaxClassification = 14.5
          let adjustedMaxClassification = baseMaxClassification

          if (isInternational) {
            baseMaxClassification = 14.0
            adjustedMaxClassification = 14.0
          } else if (isEuroCup) {
            baseMaxClassification = 14.5
            adjustedMaxClassification = Math.min(baseMaxClassification + bonusPoints, 17.0)
          } else if (isNational && activeTeam?.rules) {
            baseMaxClassification = 14.5 // Always 14.5 for National
            adjustedMaxClassification = Math.min(baseMaxClassification + bonusPoints, activeTeam.rules.maxPointsAllowed)
          }

          // Calculate if this lineup needs bonus points to be valid
          const needsBonus = totalClassification > baseMaxClassification
          const hasSufficientBonus = bonusPoints >= totalClassification - baseMaxClassification

          return {
            id: `auto-${index}`,
            players: combo,
            totalClassification,
            bonusPoints,
            totalWithBonuses,
            baseMaxClassification,
            adjustedMaxClassification,
            needsBonus,
            hasSufficientBonus,
            // Count players by category for filtering
            femaleCount: bonuses.femaleCount || 0,
            juniorCount: bonuses.juniorMaleCount || 0,
            juniorFemaleCount: bonuses.juniorFemaleCount || 0,
            foreignCount: combo.filter((p) => p.isForeign).length,
            ableBodyCount: combo.filter((p) => p.isAbleBody).length,
          }
        })

        // Add a debug message to help diagnose issues with lineup generation
        if (formattedLineups.length === 0) {
          console.log("No valid lineups found. Debug info:", {
            teamPlayers: teamPlayers.length,
            combinations: combinations.length,
            validCombinations: validCombinations.length,
            competitionLevel: activeTeam?.competitionLevel,
            rules: isNational ? activeTeam?.rules : "N/A",
          })

          setErrorMessage(
            "No valid lineups found with the current players. Try adding more players with different classifications, or check your National Rules settings.",
          )
        }

        // Cache the results
        setCachedLineups((prev) => ({
          ...prev,
          [activeTeamId]: formattedLineups,
        }))

        setAutoLineups(formattedLineups)

        // Apply filters in a separate operation
        if (formattedLineups.length > 0) {
          applyFilters(formattedLineups)
        } else {
          setFilteredLineups([])
          setGroupedLineups({})
          setErrorMessage(
            "No valid lineups found with the current players. Try adding more players with different classifications.",
          )
        }
      } catch (error) {
        console.error("Error generating lineups:", error)
        setErrorMessage("An error occurred while generating lineups. Please try again.")
        setAutoLineups([])
        setFilteredLineups([])
        setGroupedLineups({})
      } finally {
        setIsGenerating(false)
      }
    }, 0)
  }, [
    teamPlayers,
    activeTeamId,
    applyFilters,
    activeTeam,
    isInternational,
    isEuroCup,
    isNational,
    calculateBonuses,
    getCombinations,
  ])

  // Generate all valid combinations of 5 players that follow competition rules
  useEffect(() => {
    if (activeTab === "auto" && activeTeam) {
      // Check if we have cached lineups for this team
      if (cachedLineups[activeTeamId]) {
        setAutoLineups(cachedLineups[activeTeamId])
        // Don't call applyFilters here - it will be called in a separate useEffect
      } else {
        if (generationTimeoutRef.current) {
          clearTimeout(generationTimeoutRef.current)
        }
        generationTimeoutRef.current = setTimeout(() => {
          generateValidLineups()
        }, 300)
      }
    }

    return () => {
      if (generationTimeoutRef.current) {
        clearTimeout(generationTimeoutRef.current)
      }
    }
  }, [activeTab, activeTeam, activeTeamId, cachedLineups, generateValidLineups]) // Remove applyFilters from dependencies

  // Clear cached lineups when players change
  useEffect(() => {
    // Only clear the cache when players actually change
    const playerIds = players
      .filter((p) => p.teamId === activeTeamId)
      .map((p) => p.id)
      .sort()
      .join(",")

    if (prevPlayerIdsRef.current !== playerIds) {
      prevPlayerIdsRef.current = playerIds
      setCachedLineups((prev) => {
        const newCache = { ...prev }
        delete newCache[activeTeamId]
        return newCache
      })
    }
  }, [players, activeTeamId])

  // Apply filters when selected filter players change
  useEffect(() => {
    // Only run this effect if we actually have lineups to filter
    if (autoLineups.length > 0) {
      // Use a timeout to prevent rapid consecutive updates
      const filterTimeout = setTimeout(() => {
        applyFilters(autoLineups)
      }, 50)

      return () => clearTimeout(filterTimeout)
    }
  }, [selectedFilterPlayers, applyFilters, autoLineups])

  // Setup intersection observer for virtualized rendering
  const setupIntersectionObserver = useCallback(() => {
    if (observerRef.current) {
      observerRef.current.disconnect()
    }

    const newObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const id = entry.target.dataset.id
          if (entry.isIntersecting) {
            visibleItemsRef.current.add(id)
            entry.target.classList.add("visible")
          } else {
            visibleItemsRef.current.delete(id)
            if (entry.target.classList.contains("visible")) {
              entry.target.classList.remove("visible")
            }
          }
        })
      },
      { rootMargin: "100px 0px" },
    )

    // Observe all lineup cards
    setTimeout(() => {
      document.querySelectorAll(".auto-lineup-card").forEach((card) => {
        newObserver.observe(card)
      })
    }, 100)

    observerRef.current = newObserver
  }, [])

  // Setup intersection observer when groups are expanded
  useEffect(() => {
    if (activeTab === "auto" && filteredLineups.length > 0) {
      setupIntersectionObserver()
    }

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect()
      }
    }
  }, [activeTab, filteredLineups.length, Object.keys(groupedLineups).length, expandedGroups, setupIntersectionObserver])

  const toggleGroup = (classificationKey) => {
    setExpandedGroups((prev) => ({
      ...prev,
      [classificationKey]: !prev[classificationKey],
    }))
  }

  const selectAutoLineup = (lineup) => {
    setSelectedAutoLineup(lineup)
  }

  const handleSaveLineup = (lineup) => {
    setLineupToSave(lineup)
    setSuggestedLineup(null) // Ensure suggestedLineup is null when saving an auto lineup
    setShowNamingPopup(true)
  }

  // Update the saveAutoLineup function to handle both auto and suggested lineups
  const saveAutoLineup = (name) => {
    if (lineupToSave) {
      // Handle saving auto-generated lineup
      if (!name.trim()) {
        return false
      }

      // Calculate bonuses for the lineup
      const bonuses = calculateBonuses(lineupToSave.players)

      const newLineup = {
        id: Date.now().toString(),
        teamId: activeTeamId,
        name: name,
        playerIds: lineupToSave.players.map((player) => player.id),
        totalClassification: lineupToSave.totalClassification,
        bonuses: bonuses,
        adjustedMaxClassification: lineupToSave.adjustedMaxClassification,
        rating: 0,
        source: "auto",
      }

      setLineups([...lineups, newLineup])
      setLineupToSave(null)
      setShowNamingPopup(false)
      setActiveTab("saved")

      return true
    } else if (suggestedLineup) {
      // Handle saving suggested lineup
      return confirmSuggestedLineup(name)
    }

    setErrorMessage("No lineup selected to save")
    return false
  }

  const toggleFilterPlayer = (playerId) => {
    setSelectedFilterPlayers((prev) => {
      if (prev.includes(playerId)) {
        return prev.filter((id) => id !== playerId)
      } else {
        return [...prev, playerId]
      }
    })
  }

  const clearFilters = () => {
    setSelectedFilterPlayers([])
  }

  // Add a useEffect to categorize lineups by source
  useEffect(() => {
    if (activeTeamId && lineups.length > 0) {
      const teamLineups = lineups.filter((lineup) => lineup.teamId === activeTeamId)

      // Separate lineups by source
      const manual = teamLineups.filter((lineup) => !lineup.source || lineup.source === "manual")
      const auto = teamLineups.filter((lineup) => lineup.source === "auto")

      setManualLineups(manual)
      setAutoGeneratedLineups(auto)
    } else {
      setManualLineups([])
      setAutoGeneratedLineups([])
    }
  }, [lineups, activeTeamId])

  // Add a function to handle lineup deletion
  const handleDeleteLineup = (lineup) => {
    setLineupToDelete(lineup)
    setShowDeleteConfirmation(true)
  }

  // Add a function to confirm deletion
  const confirmDeleteLineup = () => {
    if (lineupToDelete) {
      // Remove the lineup from the state
      setLineups((prev) => prev.filter((lineup) => lineup.id !== lineupToDelete.id))

      // If the deleted lineup is the current lineup, clear it
      if (currentLineup && currentLineup.id === lineupToDelete.id) {
        setCurrentLineup(null)
      }

      // Close the confirmation dialog
      setShowDeleteConfirmation(false)
      setLineupToDelete(null)
    }
  }

  // Add a function to cancel deletion
  const cancelDeleteLineup = () => {
    setShowDeleteConfirmation(false)
    setLineupToDelete(null)
  }

  // Add this useEffect to automatically expand the filter section if filters are selected
  useEffect(() => {
    if (selectedFilterPlayers.length > 0 && !isFilterSectionExpanded) {
      setIsFilterSectionExpanded(true)
    }
  }, [selectedFilterPlayers, isFilterSectionExpanded])

  return (
    <div className="modal-overlay">
      <div className="modal-content lineup-selection-modal">
        <div className="modal-header">
          <h2>Lineup Management - {activeTeam?.name}</h2>
          <button className="close-button" onClick={onClose}>
            ×
          </button>
        </div>
        <div className="lineup-tabs">
          <button
            className={`tab-button ${activeTab === "manual" ? "active" : ""}`}
            onClick={() => setActiveTab("manual")}
          >
            Manual Lineup Generator
          </button>
          <button className={`tab-button ${activeTab === "auto" ? "active" : ""}`} onClick={() => setActiveTab("auto")}>
            Auto Lineup Generator
          </button>
          <button
            className={`tab-button ${activeTab === "saved" ? "active" : ""}`}
            onClick={() => setActiveTab("saved")}
          >
            Saved Lineups
          </button>
        </div>
        <div className="tab-content">
          {activeTab === "manual" ? (
            <div className="manual-generator">
              <LineupManagement onClose={onClose} isEmbedded={true} />
            </div>
          ) : activeTab === "auto" ? (
            <div className="auto-generator">
              <div className="auto-generator-header">
                <h3>
                  Auto Lineup Generator <span className="limit-note">({activeTeam?.competitionLevel} Rules)</span>
                </h3>
                {errorMessage && <div className="error-message">{errorMessage}</div>}
                {isGenerating && (
                  <div className="generating-message">Generating lineups... This may take a moment.</div>
                )}
              </div>

              {/* Player Filter Section - Now Collapsible */}
              {activeTab === "auto" && (
                <div className="smart-suggestions-section">
                  <div className="smart-suggestions-header">
                    <h4>Smart Lineup Suggestions</h4>
                  </div>
                  <div className="smart-suggestions-controls">
                    <button
                      className="suggest-lineup-button"
                      onClick={generateSuggestedLineup}
                      disabled={isSuggestingLineup || teamPlayers.length < 5}
                    >
                      {isSuggestingLineup ? "Generating..." : "Suggest Best Lineup"}
                    </button>
                    <select
                      className="strategy-preference-dropdown"
                      value={strategyPreference}
                      onChange={(e) => setStrategyPreference(e.target.value)}
                      disabled={isSuggestingLineup}
                    >
                      {getAvailableStrategies().map((strategy) => (
                        <option key={strategy.value} value={strategy.value}>
                          {strategy.label}
                        </option>
                      ))}
                    </select>
                  </div>

                  {suggestionError && <div className="suggestion-error">{suggestionError}</div>}

                  {isShowingSuggestion && suggestedLineup && (
                    <div className="suggested-lineup-preview">
                      <div className="suggested-lineup-header">
                        <h4>Suggested Lineup Preview</h4>
                        <div className="suggested-lineup-stats">
                          <span className="suggested-lineup-classification">
                            {suggestedLineup.totalClassification.toFixed(1)} pts
                            {suggestedLineup.bonusPoints > 0 && (
                              <span className="suggested-lineup-bonus">
                                {" "}
                                (+{suggestedLineup.bonusPoints.toFixed(1)})
                              </span>
                            )}
                          </span>
                          {(isEuroCup || isNational) && (
                            <span className="suggested-lineup-after-bonus">
                              Lineup After Bonus:{" "}
                              {(suggestedLineup.totalClassification - suggestedLineup.bonusPoints).toFixed(1)}/14.5
                            </span>
                          )}
                        </div>
                      </div>

                      <div className="suggested-lineup-players">
                        {suggestedLineup.players.map((player) => (
                          <div key={player.id} className="suggested-lineup-player">
                            <span className="player-name">{player.name}</span>
                            <div className="player-attributes">
                              {(isEuroCup || isNational) && (
                                <div className="player-category-chips">
                                  {player.category === "Female" && <span className="player-gender female">F</span>}
                                  {player.category === "Junior" && <span className="player-age junior">J</span>}
                                  {player.category === "Junior Female" && (
                                    <>
                                      <span className="player-gender female">F</span>
                                      <span className="player-age junior">J</span>
                                    </>
                                  )}
                                  {player.category === "Female Able-Bodied" && (
                                    <span className="player-status able-body female-able-body">FAB</span>
                                  )}
                                  {player.category === "Male Able-Bodied" && (
                                    <span className="player-status able-body male-able-body">MAB</span>
                                  )}
                                </div>
                              )}
                              <span className="player-classification">{player.classification}</span>
                            </div>
                          </div>
                        ))}
                      </div>

                      <div className="suggested-lineup-actions">
                        <button className="save-suggested-lineup-button" onClick={() => setShowNamingPopup(true)}>
                          Save
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}

              <div className={`player-filter-section ${isFilterSectionExpanded ? "expanded" : "collapsed"}`}>
                <div
                  className="filter-section-header"
                  onClick={() => setIsFilterSectionExpanded(!isFilterSectionExpanded)}
                >
                  <div className="filter-section-title">
                    <h4>Filter Lineups by Player</h4>
                    {selectedFilterPlayers.length > 0 && (
                      <span className="filter-count">{selectedFilterPlayers.length} selected</span>
                    )}
                  </div>
                  <div className="filter-section-actions">
                    {selectedFilterPlayers.length > 0 && (
                      <button
                        className="clear-filters-button"
                        onClick={(e) => {
                          e.stopPropagation()
                          clearFilters()
                        }}
                      >
                        Clear Filters
                      </button>
                    )}
                    <span className="filter-toggle-icon">{isFilterSectionExpanded ? "▲" : "▼"}</span>
                  </div>
                </div>

                <div className="filter-section-content">
                  <p className="filter-description">
                    Select players to filter lineups that include all selected players.
                  </p>
                  <div className="filter-players-grid">
                    {teamPlayers.map((player) => {
                      const isSelected = selectedFilterPlayers.includes(player.id)
                      const hasBonus =
                        (isEuroCup || isNational) &&
                        player.category !== "Senior" &&
                        player.category !== "Male Able-Bodied"
                      const bonusAmount = calculateBonuses([player]).totalBonus

                      return (
                        <div
                          key={player.id}
                          className={`filter-player-card ${isSelected ? "selected" : ""} ${hasBonus ? "has-bonus" : ""}`}
                          onClick={() => toggleFilterPlayer(player.id)}
                        >
                          <div className="filter-player-name">{player.name}</div>
                          <div className="filter-player-attributes">
                            <span className="filter-player-classification">{player.classification}</span>
                            {hasBonus && bonusAmount > 0 && (
                              <span className="filter-player-bonus">+{bonusAmount.toFixed(1)}</span>
                            )}
                            {(isEuroCup || isNational) && (
                              <>
                                {player.category === "Female" && <span className="filter-gender female">F</span>}
                                {player.category === "Junior" && <span className="filter-age junior">J</span>}
                                {player.category === "Junior Female" && (
                                  <>
                                    <span className="filter-gender female">F</span>
                                    <span className="filter-age junior">J</span>
                                  </>
                                )}
                                {player.category === "Female Able-Bodied" && (
                                  <span className="filter-status able-body female-able-body">FAB</span>
                                )}
                                {player.category === "Male Able-Bodied" && (
                                  <span className="filter-status able-body male-able-body">MAB</span>
                                )}
                              </>
                            )}
                          </div>
                        </div>
                      )
                    })}
                  </div>
                </div>
              </div>

              {/* Classification Groups */}
              {!isGenerating && filteredLineups.length > 0 && (
                <div className="classification-groups">
                  {Object.keys(groupedLineups)
                    .sort((a, b) => Number.parseFloat(b) - Number.parseFloat(a))
                    .map((classificationKey) => (
                      <div key={classificationKey} className="classification-group">
                        <div className="classification-group-header" onClick={() => toggleGroup(classificationKey)}>
                          <span className="group-toggle">{expandedGroups[classificationKey] ? "▼" : "►"}</span>
                          <span className="group-title">
                            {classificationKey} Points
                            {groupedLineups[classificationKey][0].bonusPoints > 0 && (
                              <span className="group-bonus">
                                {" "}
                                (+{groupedLineups[classificationKey][0].bonusPoints.toFixed(1)})
                              </span>
                            )}
                            <span className="group-count"> ({groupedLineups[classificationKey].length} lineups)</span>
                          </span>
                        </div>
                        {expandedGroups[classificationKey] && (
                          <div className="classification-group-content">
                            {groupedLineups[classificationKey].map((lineup) => (
                              <div
                                key={lineup.id}
                                data-id={lineup.id}
                                className={`auto-lineup-card ${selectedAutoLineup?.id === lineup.id ? "selected" : ""}`}
                                onClick={() => selectAutoLineup(lineup)}
                              >
                                {/* Update the auto-lineup-card to show bonus requirement information */}
                                <div className="auto-lineup-header">
                                  <div className="auto-lineup-stats">
                                    <span className="auto-lineup-classification">
                                      {lineup.totalClassification.toFixed(1)} pts
                                      {lineup.bonusPoints > 0 && (
                                        <span className="auto-lineup-bonus"> (+{lineup.bonusPoints.toFixed(1)})</span>
                                      )}
                                    </span>
                                    {(isEuroCup || isNational) && (
                                      <span className="auto-lineup-after-bonus">
                                        After Bonus: {(lineup.totalClassification - lineup.bonusPoints).toFixed(1)}/14.5
                                      </span>
                                    )}
                                  </div>
                                </div>
                                <div className="auto-lineup-players">
                                  {lineup.players.map((player) => (
                                    <div key={player.id} className="auto-lineup-player">
                                      <span className="player-name">{player.name}</span>
                                      <div className="player-attributes">
                                        {(isEuroCup || isNational) && (
                                          <div className="player-category-chips">
                                            {player.category === "Female" && (
                                              <span className="player-gender female">F</span>
                                            )}
                                            {player.category === "Junior" && (
                                              <span className="player-age junior">J</span>
                                            )}
                                            {player.category === "Junior Female" && (
                                              <>
                                                <span className="player-gender female">F</span>
                                                <span className="player-age junior">J</span>
                                              </>
                                            )}
                                            {player.category === "Female Able-Bodied" && (
                                              <span className="player-status able-body female-able-body">FAB</span>
                                            )}
                                            {player.category === "Male Able-Bodied" && (
                                              <span className="player-status able-body male-able-body">MAB</span>
                                            )}
                                          </div>
                                        )}
                                        <span className="player-classification">{player.classification}</span>
                                      </div>
                                    </div>
                                  ))}
                                </div>
                                <div className="auto-lineup-actions">
                                  <button
                                    className="save-lineup-button"
                                    onClick={(e) => {
                                      e.stopPropagation()
                                      handleSaveLineup(lineup)
                                    }}
                                  >
                                    Save!
                                  </button>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    ))}
                </div>
              )}

              {!isGenerating && filteredLineups.length === 0 && !errorMessage && (
                <div className="no-lineups-message">
                  No lineups available. Try adjusting your filters or adding more players.
                </div>
              )}
            </div>
          ) : (
            <div className="saved-lineups-tab">
              <div className="saved-lineups-header">
                <h3>Saved Lineups</h3>
                <p className="saved-lineups-description">Here are your manually created and auto-generated lineups.</p>
              </div>

              <div className="saved-lineups-section">
                <div className="saved-section-header">
                  <h4>Manual Lineups</h4>
                  <span className="lineup-count">{manualLineups.length}</span>
                </div>
                {manualLineups.length > 0 ? (
                  <div className="saved-lineups-grid">
                    {manualLineups.map((lineup) => {
                      // Get the players for this lineup
                      const lineupPlayers = lineup.playerIds
                        .map((playerId) => {
                          return players.find((p) => p.id === playerId)
                        })
                        .filter(Boolean)

                      return (
                        <div key={lineup.id} className="saved-lineup-card">
                          <div className="saved-lineup-header">
                            <span className="saved-lineup-classification">
                              {lineup.totalClassification.toFixed(1)} pts
                              {lineup.bonuses && lineup.bonuses.totalBonus > 0 && (
                                <span className="auto-lineup-bonus"> (+{lineup.bonuses.totalBonus.toFixed(1)})</span>
                              )}
                            </span>
                          </div>
                          <div className="saved-lineup-players">
                            {lineupPlayers.map((player) => (
                              <div key={player.id} className="saved-lineup-player">
                                <span className="player-name">{player.name}</span>
                                <div className="player-attributes">
                                  {(isEuroCup || isNational) && (
                                    <div className="player-category-chips">
                                      {player.category === "Female" && <span className="player-gender female">F</span>}
                                      {player.category === "Junior" && <span className="player-age junior">J</span>}
                                      {player.category === "Junior Female" && (
                                        <>
                                          <span className="player-gender female">F</span>
                                          <span className="player-age junior">J</span>
                                        </>
                                      )}
                                      {player.category === "Female Able-Bodied" && (
                                        <span className="player-status able-body female-able-body">FAB</span>
                                      )}
                                      {player.category === "Male Able-Bodied" && (
                                        <span className="player-status able-body male-able-body">MAB</span>
                                      )}
                                    </div>
                                  )}
                                  <span className="player-classification">{player.classification}</span>
                                </div>
                              </div>
                            ))}
                          </div>
                          <div className="saved-lineup-actions">
                            <button
                              className="use-lineup-button"
                              onClick={() => setCurrentLineup(lineup)}
                              disabled={currentLineup && currentLineup.id === lineup.id}
                            >
                              {currentLineup && currentLineup.id === lineup.id ? "Active" : "Use!"}
                            </button>
                          </div>
                        </div>
                      )
                    })}
                  </div>
                ) : (
                  <div className="empty-lineups-message">No manual lineups created yet.</div>
                )}
              </div>

              <div className="saved-lineups-section">
                <div className="saved-section-header">
                  <h4>Auto-Generated Lineups</h4>
                  <span className="lineup-count">{autoGeneratedLineups.length}</span>
                </div>
                {autoGeneratedLineups.length > 0 ? (
                  <div className="saved-lineups-grid">
                    {autoGeneratedLineups.map((lineup) => {
                      // Get the players for this lineup
                      const lineupPlayers = lineup.playerIds
                        .map((playerId) => {
                          return players.find((p) => p.id === playerId)
                        })
                        .filter(Boolean)

                      return (
                        <div key={lineup.id} className="saved-lineup-card auto">
                          <div className="saved-lineup-header">
                            <span className="saved-lineup-classification">
                              {lineup.totalClassification.toFixed(1)} pts
                              {lineup.bonuses && lineup.bonuses.totalBonus > 0 && (
                                <span className="auto-lineup-bonus"> (+{lineup.bonuses.totalBonus.toFixed(1)})</span>
                              )}
                            </span>
                          </div>
                          <div className="saved-lineup-players">
                            {lineupPlayers.map((player) => (
                              <div key={player.id} className="saved-lineup-player">
                                <span className="player-name">{player.name}</span>
                                <div className="player-attributes">
                                  {(isEuroCup || isNational) && (
                                    <div className="player-category-chips">
                                      {player.category === "Female" && <span className="player-gender female">F</span>}
                                      {player.category === "Junior" && <span className="player-age junior">J</span>}
                                      {player.category === "Junior Female" && (
                                        <>
                                          <span className="player-gender female">F</span>
                                          <span className="player-age junior">J</span>
                                        </>
                                      )}
                                      {player.category === "Female Able-Bodied" && (
                                        <span className="player-status able-body female-able-body">FAB</span>
                                      )}
                                      {player.category === "Male Able-Bodied" && (
                                        <span className="player-status able-body male-able-body">MAB</span>
                                      )}
                                    </div>
                                  )}
                                  <span className="player-classification">{player.classification}</span>
                                </div>
                              </div>
                            ))}
                          </div>
                          <div className="saved-lineup-actions">
                            <button
                              className="use-lineup-button"
                              onClick={() => setCurrentLineup(lineup)}
                              disabled={currentLineup && currentLineup.id === lineup.id}
                            >
                              {currentLineup && currentLineup.id === lineup.id ? "Active" : "Use!"}
                            </button>
                          </div>
                        </div>
                      )
                    })}
                  </div>
                ) : (
                  <div className="empty-lineups-message">No auto-generated lineups saved yet.</div>
                )}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Add the naming popup */}
      {showNamingPopup && (lineupToSave || suggestedLineup) && (
        <div
          className="naming-popup-overlay"
          onClick={() => {
            setShowNamingPopup(false)
            if (!lineupToSave) {
              // If we're saving a suggested lineup, clear it when closing the modal
              setIsShowingSuggestion(false)
              setSuggestedLineup(null)
            }
          }}
        >
          <div className="naming-popup-content" onClick={(e) => e.stopPropagation()}>
            <div className="naming-popup-header">
              <h3>Save Lineup</h3>
              <button className="close-button" onClick={() => setShowNamingPopup(false)}>
                ×
              </button>
            </div>

            <div className="lineup-preview">
              <div className="lineup-preview-header">
                <span className="lineup-preview-classification">
                  {lineupToSave
                    ? lineupToSave.totalClassification.toFixed(1)
                    : suggestedLineup.totalClassification.toFixed(1)}{" "}
                  points
                  {(lineupToSave && lineupToSave.bonusPoints > 0) ||
                  (suggestedLineup && suggestedLineup.bonusPoints > 0)
                    ? ` (+${lineupToSave ? lineupToSave.bonusPoints.toFixed(1) : suggestedLineup.bonusPoints.toFixed(1)})`
                    : ""}
                </span>
              </div>
              <div className="lineup-preview-players">
                {(lineupToSave ? lineupToSave.players : suggestedLineup.players).map((player) => (
                  <div key={player.id} className="lineup-preview-player">
                    <span className="player-number">#{player.number || "00"}</span>
                    <span className="player-name">{player.name}</span>
                    <span className="player-classification">{player.classification}</span>
                  </div>
                ))}
              </div>
            </div>

            <form
              onSubmit={(e) => {
                e.preventDefault()
                const nameInput = document.getElementById("lineupName") as HTMLInputElement
                if (nameInput && nameInput.value.trim()) {
                  saveAutoLineup(nameInput.value)
                }
              }}
            >
              <div className="form-group">
                <label htmlFor="lineupName">Lineup Name</label>
                <input id="lineupName" type="text" placeholder="Enter a name for this lineup" required />
              </div>

              <div className="naming-popup-actions">
                <button type="button" className="cancel-button" onClick={() => setShowNamingPopup(false)}>
                  Cancel
                </button>
                <button type="submit" className="save-button">
                  Save Lineup
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Add the delete confirmation dialog */}
      {showDeleteConfirmation && lineupToDelete && (
        <div className="delete-confirmation-overlay">
          <div className="delete-confirmation-modal">
            <h3>Delete Lineup</h3>
            <p>Are you sure you want to delete the lineup "{lineupToDelete.name}"? This action cannot be undone.</p>
            <div className="confirmation-actions">
              <button className="cancel-button" onClick={cancelDeleteLineup}>
                Cancel
              </button>
              <button className="confirm-delete-button" onClick={confirmDeleteLineup}>
                Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default LineupSelectionModal


